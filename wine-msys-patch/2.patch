From 41d1a071dac6f4a814ad74b7eb4757018a8ed6fb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20=C3=9Cbelacker?= <bernhardu@mailbox.org>
Date: Tue, 30 May 2023 09:19:30 +0200
Subject: [PATCH] server: Reset reported_events if socket gets reused.

MSYS setup tries to setup some pacman/gpg key configuration.
This involves starting dirmngr.exe which unfortunately hangs.
Therefore gpg reports:
  gpg: connecting dirmngr at '/etc/pacman.d/gnupg/S.dirmngr' failed: IPC connect call failed
And fails therefore "silently".

The hang in dirmngr.exe looks to be a result of reusing a socket twice.
When the first connection attempt failed, wineserver still has
the reported_events set.
Therefore on the second attempt WSAEnumNetworkEvents does no longer
report those events.
But fhandler_socket_wsock::wait_for_events gets just left when
there are some events received.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=53574

dirmngr.exe --server --no-detach --homedir /etc/pacman.d/gnupg --verbose

(gdb) bt
#0  fhandler_socket_wsock::evaluate_events (this=0x800028718, event_mask=48, events=@0x67dfc278: 0, erase=true) at /home/bernhard/MSYS2-packages/msys2-runtime/src/msys2-runtime/winsup/cygwin/fhandler/socket_inet.cc:307
#1  0x000000018015a287 in fhandler_socket_wsock::wait_for_events (this=0x800028718, event_mask=48, flags=0) at /home/bernhard/MSYS2-packages/msys2-runtime/src/msys2-runtime/winsup/cygwin/fhandler/socket_inet.cc:404
#2  0x000000018015b267 in fhandler_socket_inet::connect (this=0x800028718, name=0x67dfc810, namelen=16) at /home/bernhard/MSYS2-packages/msys2-runtime/src/msys2-runtime/winsup/cygwin/fhandler/socket_inet.cc:802
#3  0x000000018008c63c in cygwin_connect (fd=3, name=0x67dfc810, namelen=16) at /home/bernhard/MSYS2-packages/msys2-runtime/src/msys2-runtime/winsup/cygwin/net.cc:709
#4  0x00000001801c348b in _sigfe () at sigfe.s:36
#5  0x00000005a3099a57 in __assuan_connect (ctx=<optimized out>, sock=<optimized out>, addr=<optimized out>, length=<optimized out>) at system-posix.c:430
#6  0x00000005a30922c6 in _assuan_connect (ctx=ctx@entry=0xa00020830, sock=sock@entry=3, addr=addr@entry=0x67dfc810, length=length@entry=16) at system.c:412
#7  0x00000005a30989c8 in socks5_connect (ctx=ctx@entry=0xa00020830, sock=sock@entry=3, socksport=socksport@entry=9050, credentials=credentials@entry=0x0, hostname=hostname@entry=0x5a309d7fa <okstr+1466> "", hostport=hostport@entry=0, addr=addr@entry=0x0, length=length@entry=0) at assuan-socket.c:754
#8  0x00000005a3099315 in _assuan_sock_connect_byname (ctx=0xa00020830, host=host@entry=0x0, port=port@entry=0, reserved=reserved@entry=0, credentials=credentials@entry=0x0, flags=flags@entry=2) at assuan-socket.c:1148
#9  0x00000005a30993f7 in assuan_sock_connect_byname (host=host@entry=0x0, port=port@entry=0, reserved=reserved@entry=0, credentials=credentials@entry=0x0, flags=flags@entry=2) at assuan-socket.c:1497
#10 0x0000000100402531 in dirmngr_use_tor () at dirmngr.c:607
#11 0x000000010040256c in set_tor_mode () at dirmngr.c:582
#12 0x00000001004025eb in post_option_parsing () at dirmngr.c:898
#13 0x0000000100403532 in main (argc=<optimized out>, argv=<optimized out>) at dirmngr.c:1211
(gdb) print evts.lNetworkEvents
$1 = 0
---
 dlls/ws2_32/tests/sock.c | 47 ++++++++++++++++++++++++++++++++++++++++
 server/sock.c            |  4 ++++
 2 files changed, 51 insertions(+)

diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index a3fb6744235..204ef092a59 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -14520,12 +14520,56 @@ static void test_valid_handle(void)
     closesocket(server);
 }
 
+static void test_msys(void)
+{
+    int ret;
+    WORD ver = MAKEWORD (2, 2);
+    WSADATA data;
+    SOCKET s;
+    struct sockaddr_in addr;
+    HANDLE wsock_evt;
+    WSANETWORKEVENTS evts = { 0 };
+
+    ok ( WSAStartup ( ver, &data ) == 0, "WSAStartup failed\n" );
+
+    s = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
+    ok(s!=INVALID_SOCKET, "socket() failed error: %d\n", WSAGetLastError());
+    if(s == INVALID_SOCKET) return;
+
+    wsock_evt = CreateEventA(NULL, TRUE, FALSE, NULL);
+    ret = WSAEventSelect(s, wsock_evt, FD_READ|FD_WRITE|FD_OOB|FD_ACCEPT|FD_CONNECT|FD_CLOSE);
+    ok(!ret, "WSAEventSelect failed with %u\n", WSAGetLastError());
+
+    memset(&addr, 0, sizeof addr);
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+
+    addr.sin_port = htons(9050);
+    ret = connect(s, (struct sockaddr*)&addr, sizeof(addr));
+    ok(ret == SOCKET_ERROR, "unexpected succeeding connect\n");
+
+    Sleep(4000);
+    ret = WSAEnumNetworkEvents(s, wsock_evt, &evts);
+    ok(!ret, "WSAEnumNetworkEvents failed with %u\n", WSAGetLastError());
+    ok(evts.lNetworkEvents == 16, "evts.lNetworkEvents == %ld expected\n", evts.lNetworkEvents);
+
+    addr.sin_port = htons(9150);
+    ret = connect(s, (struct sockaddr*)&addr, sizeof(addr));
+    ok(ret == SOCKET_ERROR, "unexpected succeeding connect\n");
+
+    Sleep(4000);
+    ret = WSAEnumNetworkEvents(s, wsock_evt, &evts);
+    ok(!ret, "WSAEnumNetworkEvents failed with %u\n", WSAGetLastError());
+    ok(evts.lNetworkEvents == 16, "evts.lNetworkEvents == %ld expected\n", evts.lNetworkEvents);
+}
+
 START_TEST( sock )
 {
     int i;
 
 /* Leave these tests at the beginning. They depend on WSAStartup not having been
  * called, which is done by Init() below. */
+    if (0) {
     test_WithoutWSAStartup();
     test_WithWSAStartup();
 
@@ -14636,4 +14680,7 @@ START_TEST( sock )
     test_send();
 
     Exit();
+    }
+
+    test_msys();
 }
diff --git a/server/sock.c b/server/sock.c
index e064f867ff4..b1bedc215fb 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -2723,6 +2723,10 @@ static void sock_ioctl( struct fd *fd, ioctl_code_t code, struct async *async )
 
             case SOCK_UNCONNECTED:
             case SOCK_CONNECTIONLESS:
+                if (sock->reported_events) {
+                    fprintf(stderr, "sock->fd=%p: resetting sock->reported_events from 0x%x to 0.\n", sock->fd, sock->reported_events);
+                    sock->reported_events = 0;
+                }
                 break;
         }
 
-- 
GitLab

